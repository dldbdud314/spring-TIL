### 초난감 DAO

- 초기 DAO의 관심사항:
  1. DB 연결 커넥션 관련
  2. SQL 작성 및 실행
  3. 커넥션 닫기

### 관심사의 분리

- 분리와 확장을 고려한 설계 (why? 소프트웨어는 계속 변하기 때문)
- 관심사의 분리: 관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어지게 하는 것
- 변화는 보통 한가지 관심사항에 집중

### 리팩토링

1. 메소드 추출(중복 코드 제거) : getConnection()
2. 상속을 통한 서브클래스 구현

![image](https://user-images.githubusercontent.com/57944099/178170320-3b36b971-c1f9-4f2c-aafd-78c09553c3ad.png)

- 템플릿 메소드 패턴, 팩토리 메소드 패턴으로 관심사항이 다른 코드 분리, 서로 독립적으로 분리, 확장이 가능하게끔
- BUT 상속의 단점:
  - 후에 다른 목적으로 상속 적용 힘들다 (다중상속 불가)
  - 상속관계는 생각보다 밀접하다
  - 다른 DAO에 DB 커넥션 생성 코드 적용 안됨

### 확장하기

![image](https://user-images.githubusercontent.com/57944099/178170999-acbec06f-5e24-4c9c-8fc9-a22fbe2f6bd5.png)

- 기능 확장 X

  - 구체클래스에 종속적이기 때문에

- **인터페이스 활용하기 -> "추상화"**
  ![image](https://user-images.githubusercontent.com/57944099/178171709-22906d1b-0d45-481e-8a01-78d7089b3207.png)

- `connectionMaker = new DConnectionMaker()` -> 추상화에만 의존하지 않는다

- 외부로부터 메소드 파라미터나 생성자 파라미터로 전달받기

```java
public UserDao(ConnectionMaker connectionMaker){
    this.connectionMaker = connectionMaker;
}
```

- 클라이언트의 책임: 런타임 오브젝트 관계를 갖는 구조로 만들어주는 것
- 최종:
  ![image](https://user-images.githubusercontent.com/57944099/178172368-f12d9ae8-a248-44dd-9f84-22700cd0dc7e.png)

#### 원칙과 패턴

- 개방-폐쇄 원칙, OCP
- 높은 응집도 & 낮은 결합도
- 전략 패턴

### 오브젝트 팩토리

- 팩토리: 객체의 생성 방법 결정하고, 만들어진 오브젝트 return
- 설계도로서의 팩토리
  - 컴포넌트: 핵심적인 데이터 로직, 기술 로직
  - 설계도: 오브젝트들을 구성하고 그 관계를 정의

![image](https://user-images.githubusercontent.com/57944099/178173295-95c01956-fd52-4566-beec-d5fa565f7889.png)

### 제어의 역전, IoC

- 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지도, 생성하지도 않는다. 또 자신도 어디서 만들어지고 어디서 사용되는지 알 수 없다
- 적용 사례:
  - 서블릿
  - 템플릿 메소드 패턴
  - 프레임워크
- UserDao와 DaoFactory <- IoC 적용
  - 구현클래스 결정 및 오브젝트 생성 제어권이 UserDao -> DaoFactory로 넘어감

### 스프링 IoC - 애플리케이션 컨텍스트 & 설정 정보

- 빈: 스프링이 제어권을 갖고 직접 만들고 관계 부여
- 빈 팩토리: 빈의 생성과 관계 설정 같은 제어를 담당하는 IoC 오브젝트

### 애플리케이션 컨텍스트의 동작방식

(a.k.a IoC 컨테이너/스프링 컨테이너/빈팩토리)

- IoC를 적용해서 관리할 모든 오브젝트에 대한 생성, 관계 설정 담당
- 대신 그런 생성 및 연관관계 정보를 별도의 설정 정보를 통해 얻음

![image](https://user-images.githubusercontent.com/57944099/178174681-f564a91a-643e-45d8-8d14-3edaacba9dd2.png)

- 장점:
  - 종합 IoC 서비스 제공
  - 클라이언트는 구체적인 팩토리 클래스를 몰라도 됨

### 싱글톤 레지스트리

- 애플리케이션 컨텍스트는 **싱글톤 레지스트리**다
- 싱글톤 레지스트리란?

  - 스프링에서 제공하는 싱글톤 형태의 오브젝트를 만들고 관리하는 기능

- 직접 싱글톤 패턴을 구현하는 것의 한계:
  - private 생성자로 인해 상속 불가, 객체지향적인 설계의 장점을 이용하기 어렵다
  - 테스트 하기 힘들다
  - 서버 환경에서 싱글톤이 하나만 만들어지는 것을 보장하지 못한다

### 싱글톤과 오브젝트의 상태 (주의점)

- 여러 스레드가 동시에 접근해서 사용하는 멀티스레드 환경에서의 싱글톤 빈 -> 상태 관리 중요
- **stateless** 하게 설계할 것!
  : 파라미터, 로컬변수, 리턴 값 등을 이용
  - 읽기 전용의 정보는 인스턴스 변수로 관리해도 괜찮다
